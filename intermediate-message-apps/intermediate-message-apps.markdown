```metadata
author: "By Rich Turton"
number: "6"
title: "Chapter 6: Intermediate Message Apps"
```
# Chapter 6: Intermediate Message Apps

## Introduction

Chapter 5 showed you how you can build apps containing custom stickers for use in Messages. In this chapter you'll learn about sending fully custom, updatable messages. You're going to build a drawing and guessing game called **WenderPic**, where one player tries to draw something with a limited supply of ink, and their opponent tries to guess what it is. Drawings and guesses all travel via iMessage. 

Read on to find out about the power of the Messages framework!

## Getting Started

Open the **WenderPic** starter project that comes with the materials for this chapter. There's quite a lot already present in the project, but none of it is really to do with Messages. Here's a quick tour of the project:

- As you've already seen, everything interesting is in the **MessagesExtension** group. There is no accompanying "full" app. 
- The **Models** group contains the model object for the game, **WenderPicGame**. 
- The **Controllers** group contains the three view controllers used to play the game - **SummaryViewController**, which shows the title of the game and a start button, **DrawingViewController**, which handles the drawing, and **GuessesViewController**, which allows you to enter a guess.
- **MainInterface.storyboard** shows the root messages view controller, and the UI for the three game controllers. You'll build code to add these as child view controllers. 

The root messages view controller does a lot more work in this project than it did in the previous chapter, so let's start with an overview of that.

## The Messages App View Controller

You briefly encountered `MSMessagesAppViewController` in the previous chapter. In this project you'll do a lot more work with it. As you know already, it's a `UIViewController` subclass, but it gets several interesting methods called on it by the Messages framework. 

There are lifecycle methods, similar to `viewWillAppear(_:)` and friends:

- `willBecomeActive(with:)`: called when your messages app is activated. The current conversation (you'll learn about that later) is passed in.
- `didResignActive(with:)`: called when the user is done with your app, either because they switched conversations, switched to another app, or left messages.

There are methods relating to the current conversation:

- `didReceive(_: conversation:)`: called when a message is received _that was generated by your extension_. It's important to note that your extension does _not_ get told about every message your user receives. 
- `didStartSending(_: conversation:)` and `didCancelSending(_: conversation:)`: called when the user hits send for one of your messages, or cancels sending.

Finally, there are methods relating to presentation style transitions. Messages apps can have two presentation styles - Compact, where the app fills the space normally taken by the keyboard, or Expanded, where the app fills the screen. There are `willTransition(to:)` and `didTransition(to:)` methods called when the presentation style changes. 

The idea of the `MSMessagesAppViewController` is to act as the root of the rest of your app, so it can handle all the things above. Typically, the interface for your app is handled in separate view controllers which are added as children, which is what you'll do in the next part.

## Adding the first child view controller

All of the game view controllers will be added as children. Adding a child view controller involves quite a lot of boilerplate, so you'll add a utility method. 

Open **MessagesViewController.swift** and add the following extension:

```swift
// MARK: Child View Controllers
extension MessagesViewController {
  private func switchTo(viewController controller: UIViewController) {
    // Remove any existing child view controller
    for child in childViewControllers {
      child.willMove(toParentViewController: .none)
      child.view.removeFromSuperview()
      child.removeFromParentViewController()
    }
    
    // Add the new child view controller
    addChildViewController(controller)
    
    controller.view.translatesAutoresizingMaskIntoConstraints = false
    view.addSubview(controller.view)
    
    NSLayoutConstraint.activate([
      controller.view.leftAnchor.constraint(equalTo: view.leftAnchor),
      controller.view.rightAnchor.constraint(equalTo: view.rightAnchor),
      controller.view.topAnchor.constraint(equalTo: view.topAnchor),
      controller.view.bottomAnchor.constraint(equalTo: view.bottomAnchor)
      ])
    
    controller.didMove(toParentViewController: self)
  }
}
```

This is fairly standard stuff - remove any existing child view controllers, add the new one and pin its view to all edges. 

The first view controller the user will see is the Summary View Controller - this is the one with the title of the game and the "new game" button on it. 

Add a utility method to the extension to create a new summary view controller:

```swift
private func instantiateSummaryViewController(game: WenderPicGame?) -> UIViewController {
  guard let controller = storyboard?.instantiateViewController(withIdentifier: "summaryVC") as? SummaryViewController else { fatalError("Unable to instantiate a summary view controller") }
  
  controller.game = game
  return controller
}
```

This method creates and configures a new instance of the view controller from the storyboard. 

The decision for which of the three game view controllers you will show at any point is based on a combination of the current conversation and the current presentation style. This method, which you will fill out as the project progresses, makes that decision. For now, you'll just show the summary. Add this to the extension:

```swift
private func presentViewController(forConversation conversation: MSConversation, withPresentationStyle style: MSMessagesAppPresentationStyle) {
  let controller: UIViewController
  
  // TODO: Create the right view controller here
  controller = instantiateSummaryViewController(game: nil)
  switchTo(viewController: controller)
}
```

The final piece is to call this method at the right time. Add the following code to `willBecomeActive(with:)`:

```swift
presentViewController(forConversation: conversation, withPresentationStyle: presentationStyle)
```

Build and run, attaching to the Messages app as you did in the previous chapter, and you'll see the summary view controller:

![iphone](images/SummaryShown.png)

Tapping the "New Game" button does nothing. You'll fix that now. 

Switch back to Xcode and open **MessagesViewController.swift**. The summary view controller has a delegate, which you need to set. Make `MessagesViewController` conform to `SummaryViewControllerDelegate` by adding the following extension:

```swift
extension MessagesViewController: SummaryViewControllerDelegate {
  func handleSummaryTap(forGame game: WenderPicGame?) {
    requestPresentationStyle(.expanded)
  }
}
```

When the button on the summary view controller is tapped, you want the app to change to the expanded presentation style, so you can do full screen drawing. 

Set the summary view controller's delegate by adding this line to `instantiateSummaryViewController(game:)`, above the `return` statement:

```swift
controller.delegate = self
```

Build and run again, then tap the button - the app transitions to the expanded size!

![iphone](images/SummaryShown2.png)

That's only half of what you want. In the next part you'll switch to the drawing view controller as well. 

## Switching view controllers

When the user taps to start a new game, the app transitions to the expanded presentation style. You want to create a new `WenderPicGame` and show the drawing view controller.

You need to call the utility method which chooses and presents the view controller whenever a change in the presentation style occurs. To do this, open **MessagesViewController.swift** and add the following code to `willTransition(to:)`:

```swift
if let conversation = activeConversation {
  presentViewController(forConversation: conversation,
                        withPresentationStyle: presentationStyle)
}
```

`activeConversation` is an optional property of `MSMessagesAppViewController`. 

Inside the "Child View Controllers" extension, add a utility method to the to make a new drawing view controller:

```swift
private func instantiateDrawingViewController(game: WenderPicGame?) -> UIViewController {
  guard let controller = storyboard?.instantiateViewController(withIdentifier: "drawingVC") as? DrawingViewController else { fatalError("Unable to instantiate a drawing view controller") }
  
  controller.game = game
  return controller
}
```

This is almost identical to the method that creates the summary view controller.

Move to `presentViewController(forConversation: withPresentationStyle:)`. Find the `TODO:` comment you added earlier, and replace it and the line where you create the summary view controller with this code:

```swift
switch style {
case .compact:
  controller = instantiateSummaryViewController(game: nil)
case .expanded:
  let newGame = WenderPicGame.newGame(drawerId: conversation.localParticipantIdentifier)
  controller = instantiateDrawingViewController(game: newGame)
}
```

Instead of always creating the summary view controller, you are now switching on the presentation style. The summary controller will be shown when the app is compact, and the drawing controller when expanded. 

You create a new `WenderPicGame` using a UUID which represents the person who is doing the drawing. This UUID is available as a property on `MSConversation` and is consistent as long as the user keeps your app installed and enabled. This is going to allow the app to track the progress of a game between two participants. 

Build and run, and tap the new game button, then do some drawing!

![iphone](images/Drawing1.png)

When you've run out of ink and you hit the **Done** button... nothing happens. You want to pack up your image in a message and send it to your friend. You'll do that in the next part.

## Creating a message

The Messages framework has these model classes - a Conversation, a Message and a Session. Here's a brief overview of each one.

### Conversation

`MSConversation` represents the back-and-forth stream of messages currently visible in the Messages app. This is the view with the speech bubbles when you are texting. 

You don't have full access to the conversation, which is understandable given the privacy implications that would have. You _can_ access the following properties:

- `localParticipantIdentifier`: a UUID representing the user of the device, the person who is sending messages from your extension. You used this when creating a new game earlier.
- `remoteParticipantIdentifiers`: an array of UUIDs representing the recipient(s) of any sent messages.
- `selectedMessage`: an optional property representing the selected message, _if_ the selected message was generated by your extension. 

A conversation also has methods to add attachments, messages, text or stickers into the input field. Sending is still at the discretion of the user. This is similar to the way `MFMessageComposeViewController` works - your app can populate a message and set it all up ready to go, but the user still has control over the actual sending of the message. 

### Message

`MSMessage` represents an interactive message. These are unique to, and only accessible by, your messages app. If someone receives a message created by your extension, and they don't have it installed, they'll be prompted to install it. The most important properties of a message, which must be set before the message is sent, are the `layout` and the `url`. 

The layout is a separate class which controls how the message appears in the conversation. You don't get to customize the layout, you simply set whichever of its properties (image, caption and so on) are appropriate for your message. 

The URL is your opportunity to send any custom data along with the message. You can include key-value pairs using `NSURLQueryItem`, which you'll learn more about later.

### Session

`MSSession` is used when a message is intended to be updated as the conversation progresses, rather than having new entries in the conversation each time. If you create a message and associate it with a session, it will be shown normally. If you send _another_ message with the same session, the previous message will be moved down to the bottom of the conversation and be updated with the new information. 

Imagine playing a game of tic-tac-toe over messages. With no sessions, the transcript would be a series of board images as more and more moves were played. With sessions, you'd only have one board image, with the latest positions on it. You can decide for yourself if sessions make sense for your messaging app. 

### Back to work!

With that bit of theory done, it's time to apply it. At the moment, you can draw a picture, but not send it to your friend. 

In **MessagesViewController.swift**, add the following method in a new extension:

```swift
extension MessagesViewController {
  private func composeMessage(with game: WenderPicGame, 
  caption: String, session: MSSession? = .none) -> MSMessage {
    //1
    let layout = MSMessageTemplateLayout()
    //2
    layout.image = game.currentDrawing
    //3
    layout.caption = caption
    //4
    let message = MSMessage(session: session ?? MSSession())
    message.layout = layout
    
    return message
  }
}
```

Here's the step-by-step:

1. `MSMessageTemplateLayout` is currently the only available message layout class, so you have to use it.
2. The drawing view controller will update the game with the current state of the image. You use this image for the layout, so it will be part of the message.
3. The caption is text that will appear under the image
4. You create a new message, either with the existing session, or with a new session if one does not exist.

The drawing view controller, like the summary view controller, has a delegate which is called when the done button is tapped. Add the following extension to **MessagesViewController.swift**:

```swift
extension MessagesViewController: DrawingViewControllerDelegate {
  func handleDrawingComplete(game: WenderPicGame?) {
    defer { dismiss() }
    guard let
      conversation = activeConversation,
      game = game
    else { return }
    
    let message = composeMessage(with: game, caption: "Guess my WenderPic!", session: conversation.selectedMessage?.session!)
    
    conversation.insert(message) { (error) in
      if let error = error {
        print(error)
      }
    }
  }
}
```

Also update `instantiateDrawingViewController(game:)` so that the delegate is set:

```swift
controller.delegate = self
```

Build and run, do a drawing and tap the done button - your message is ready to send!

![iphone](images/MessageReady.png)

The appearance of the message, with the image and caption, are defined by the layout object. You don't get any control over the appearance, but you don't have to do any work either :]

Tap the send button and the message will go to the other pretend contact in the simulator. Tap the back button and switch to the other side of the conversation, and you'll see what the message looks like to the recipient. If you tap the message, you just get shown another drawing controller for a new game. 

What's happening here is that when the user taps the message, the extension transitions to the expanded presentation style, and at the moment that just starts a new game. In the next part you're going to add some data to the message so that the game state can be passed back and forth between participants, which will allow the recipient of a WenderPic to make and send a guess. 

## Custom message content

In the discussion of `MSMessage` earlier you learned that the `url` property was your opportunity to add custom data to a message. You're going to do that now to include enough data in the message for the recipient to be able to recreate the `WenderPicGame` from the sender's device. 

> **Note:** Messages apps are not available on macOS. The `url` property has a second job - if your message is opened on a Mac, it will open the URL. We're not covering that in this chapter as it would involve you setting up a server that could handle the games. 

The way to include data in a URL is to use `URLQueryItem`. This class represents a single key-value pair in a URL's query section - this is the part of the URL you'd see as `?key=value&otherKey=otherValue`. 

Open **WenderPicGame.swift** and add the following extension:

```swift
// MARK: Encoding / Decoding
extension WenderPicGame {
  var queryItems: [URLQueryItem] {
    var items = [URLQueryItem]()
    
    items.append(URLQueryItem(name: "word", value: word))
    items.append(URLQueryItem(name: "guesses", value: guesses.joined(separator: "::-::")))
    items.append(URLQueryItem(name: "drawerId", value: drawerId.uuidString))
    
    return items
  }
}
```

This puts everything important from the game into an array of query items. So far, that's the word that the drawing is supposed to be the person who drew it, and any guesses that have been made - you haven't done any guesses yet, but you will shortly. You don't need to worry about the image that's been drawn, since that is available via the layout object attached to the incoming message. 

Switch to **MessagesViewController.swift** and find the `composeMessage(with: caption: session:)`. Add the following code before the `return` statement:

```swift
var components = URLComponents()
components.queryItems = game.queryItems
message.url = components.url
```

You might not think that you can create a valid URL just by using query components, but it's fine. The above code makes a URL that looks like this:

```bash
?word=dog&drawerId=D5E356A9-0B6A-4441-AB6C-08D24DB255B2
```

Now you're sending some custom content with your message, it's time to receive it at the other end of the conversation. Remember that currently, when the user receives and taps a message, they just see the drawing controller again. What should happen is that you should try to recreate the game from the selected message, and decide what to do based on that. 

First of all you need to create a custom initializer for `WenderPicGame` that can take some query items and an image. Switch to **WenderPicGame.swift** and add the following inside the encoding / decoding extension:

```swift
init?(queryItems: [URLQueryItem], drawing: UIImage?) {
  var word: String?
  var guesses = [String]()
  var drawerId: UUID?
  
  for item in queryItems {
    guard let value = item.value else { continue }
    
    switch item.name {
    case "word":
      word = value
    case "guesses":
      guesses = value.components(separatedBy: "::-::")
    case "drawerId":
      drawerId = UUID(uuidString: value)
    default:
      continue
    }
  }
  
  guard let decodedWord = word, decodedDrawerId = drawerId else {
    return nil
  }
  
  self.word = decodedWord
  self.guesses = guesses
  self.currentDrawing = drawing
  self.drawerId = decodedDrawerId
}
```

This failable initializer will return a valid game if the two mandatory properties, the `word` and the `drawerId`, can be extracted from the query items. To make things a bit more useful, add another initializer that just takes an `MSMessage`: 

```swift
init?(message: MSMessage?) {
  guard let
    layout = message?.layout as? MSMessageTemplateLayout, 
    messageURL = message?.url,
    urlComponents = URLComponents(url: messageURL, resolvingAgainstBaseURL: false),
    queryItems = urlComponents.queryItems
  else {
    return nil
  }
  
  self.init(queryItems: queryItems, drawing: layout.image)
}
```

This ensures that a layout and valid URL are present before handing off to the other initializer. 

//TODO: In beta 2, the layout is not present. If this is the way things are in the final version, we'll need to change the way the image is transmitted.

Now you have the capability to create a game from a message. If the user receives a drawing from their friend, they want to see the guess view controller when they tap it. 

Switch to **MessagesViewController.swift** and add a method to create the guess view controller in the "Child View Controllers" extension:

```swift
private func instantiateGuessViewController(game: WenderPicGame?) -> UIViewController {
  guard let controller = storyboard?.instantiateViewController(withIdentifier: "guessVC") as? GuessViewController else { fatalError("Unable to instantiate a guess view controller") }

  controller.game = game
  return controller
}
```

Now find the switch statement inside `presentViewController(forConversation withPresentationStyle:)`. Replace the lines after `case .expanded:` with the following:

```swift
if let game = WenderPicGame(message: conversation.selectedMessage) {
  controller = instantiateGuessViewController(game: game)
} else {
  let newGame = WenderPicGame.newGame(
    drawerId: conversation.localParticipantIdentifier)
  controller = instantiateDrawingViewController(game: newGame)
}
```

Remember that the expanded style is requested when the user taps the new game button or taps a received message. If the user has tapped a message, then the conversation will have a selected message, so you will be able to create a game and show the guess view controller. 

Build and run, send a drawing, switch to the other conversation view and tap the message:

![iphone](images/Guess1.png)

In what should be a familiar pattern by now, you can enter a guess, but nothing will happen. The guess view controller has a delegate property, and you need to set it up. 

Add the following extension to **MessagesViewController.swift**:

```swift
extension MessagesViewController: GuessViewControllerDelegate {
  func handleGuessSubmission(forGame game: WenderPicGame, guess: String) {
    defer { dismiss() }
    guard let conversation = activeConversation else { return }
    
    let message: MSMessage
  
    if(game.check(guess: guess)) {
      // Correct answer
      message = composeMessage(with: game, caption: "üëç \(guess)", session: conversation.selectedMessage?.session)
    } else {
      // incorrect answer
      message = composeMessage(with: game, caption: "üëé \(guess)", session: conversation.selectedMessage?.session)
    }
    
    conversation.insert(message) { (error) in
      if let error = error {
        print(error)
      }
    }
  }
}
```

This method checks the guess and creates and prepares a reply to send with an appropriate caption.

Change `instantiateGuessViewController(game:)` to set the delegate property:

```swift
controller.delegate = self
```

Build and run again, send a drawing, make a guess, and you'll see your guess go back:

![iphone](images/Guessed.png) 

## Whose guess is it anyway? 

You'll have noticed that you get a very limited supply of ink in this game. This means your first drawing is highly unlikely to be guessed correctly, unless you're Henri Matisse. 

When you get an incorrect guess back, it would be good to be able to add some more drawing to give your opponent another chance. This is where the `drawerId` of the game comes in. At the moment, if you can recreate a game from the message, you show the guess view controller. You're going to change that so that if the game is one where the current user did the drawing, they get to do more drawing. 

Open **MessagesViewController.swift** and find `presentViewController(forConversation withPresentationStyle:)`. Change the code where a game has been created from the message to match the following:

// TODO: This bit also doesn't work in beta 2 - the local participant identifer is the same for both sides of the conversation in the simulator :[. You can work around it by using conversation.remoteParticipantIdentifiers.first! instead, but I didn't want to commit that to the repo. 

```swift
if let game = WenderPicGame(message: conversation.selectedMessage) {
  if game.drawerId == conversation.localParticipantIdentifier {
    controller = instantiateDrawingViewController(game: game)
  } else {
    controller = instantiateGuessViewController(game: game)
  }
} else {
```

This will show the drawing view controller if the game was originally started by the user. 

Build and run, send a drawing, make a guess, switch back to the original conversation and tap on the guess - you get to add more ink:

TODO: screenshot of more drawing... waiting for beta fixes?

Congratulations! You've successfully built a collaborative messaging app, which allows you to pass custom information back and forward between two participants. 

## Where to go from here? 

The full Messages framework documentation can be found at [https://developer.apple.com/reference/messages](https://developer.apple.com/reference/messages). 

Messages apps are an exciting new area for iOS - this is your chance to get involved on day one! 
