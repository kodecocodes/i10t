```metadata
author: "By Rich Turton"
number: "6"
title: "Chapter 6: Intermediate Message Apps"
```
# Chapter 6: Intermediate Message Apps

In the previous chapter, you saw how to build apps containing custom stickers for use in Messages. Stickers are great, but you can do far more than that.

In this chapter, you're going to learn how to send fully custom, updatable messages. This will allow you to build a game called **WenderPic**, where one player tries to draw something with a limited supply of ink, and their opponent tries to guess what it is. Drawings and guesses all travel via iMessage.

Ready to channel your inner Picasso?

## Getting started

Open the **WenderPic** starter project provided with the materials for this chapter. There's quite a lot already present in the project, but none of it really has to do with Messages. That's where you come in.

Here's a quick tour of the project:

- Just like in the previous chapter, what you're building is a **MessagesExtension**, and not a "full" app like you're used to. The code for the extension is inside the **MessagesExtension** group.
- The **Models** group contains the model object for the game, **WenderPicGame**.
- The **Controllers** group contains the three view controllers used to play the game; **SummaryViewController**, which shows the title of the game and a start button; **DrawingViewController**, which handles the drawing; and **GuessesViewController**, which lets you enter a guess.
- **MainInterface.storyboard** shows the root messages view controller and the UI for the three game controllers. You'll build code to add these as child view controllers.

In this chapter, the root messages view controller will do a lot more work than it did in the previous one, so let's start with an overview of that.

## The Messages app view controller

You briefly encountered `MSMessagesAppViewController` in the previous chapter; it's a `UIViewController` subclass, but the Messages framework calls several interesting functions on it.

There are life cycle functions, similar to `viewDidLoad(_:)`, `viewWillAppear(_:)`, and its brethren:

- `willBecomeActive(with:)`: Called when your Messages app is activated. As you'll learn later, the current conversation is passed in here.
- `didResignActive(with:)`: Called when the user is done with your app, either because they switched conversations, switched to another app, or left the Messages app.

There are functions relating to the current conversation:

- `didReceive(_: conversation:)`: Called when a message _that was generated by your extension_ is received. It's important to note that your extension does _not_ get told about every message your user receives ‚Äî only those relevant to your extension.
- `didStartSending(_: conversation:)` and `didCancelSending(_: conversation:)`: Called when the user hits send for one of your messages, or cancels sending.

Finally, there are functions relating to presentation-style transitions. Messages apps can have two presentation styles; **Compact**, where the app fills the space normally taken by the keyboard, or **Expanded**, where the app fills the entire screen. `willTransition(to:)` and `didTransition(to:)` are called when the presentation style changes.

The idea of the `MSMessagesAppViewController` is to act as the root of the rest of your Messages extension, so it can handle all the things above. Typically, the interface for your app is handled in separate view controllers which are added as children ‚Äì this is what you'll be doing in the next part.

## Adding the first child view controller

You'll add all of the game view controllers mentioned above as children of `MessagesViewController`. Adding a child view controller involves quite a lot of boilerplate, so you'll add a utility function to avoid duplicating yourself thrice.

Open **MessagesViewController.swift** and add the following extension:

```swift
// MARK: Child View Controllers
extension MessagesViewController {
  private func switchTo(viewController controller: UIViewController) {
    // Remove any existing child view controller
    for child in childViewControllers {
      child.willMove(toParentViewController: .none)
      child.view.removeFromSuperview()
      child.removeFromParentViewController()
    }

    // Add the new child view controller
    addChildViewController(controller)

    controller.view.translatesAutoresizingMaskIntoConstraints = false
    view.addSubview(controller.view)

    NSLayoutConstraint.activate([
      controller.view.leftAnchor.constraint(equalTo: view.leftAnchor),
      controller.view.rightAnchor.constraint(equalTo: view.rightAnchor),
      controller.view.topAnchor.constraint(equalTo: view.topAnchor),
      controller.view.bottomAnchor.constraint(equalTo: view.bottomAnchor)
      ])

    controller.didMove(toParentViewController: self)
  }
}
```

First, you remove any existing child view controllers, then you add the controller passed in by the function. Finally, you pin its view to all edges of the messages view controller's view.

The first view controller the user will see is the `SummaryViewController` ‚Äì a controller with the title of the game and a "new game" button.

Add the following utility function to the extension to create a new `SummaryViewController`:

```swift
private func instantiateSummaryViewController(game: WenderPicGame?) ->
  UIViewController {
  guard let controller = storyboard?.instantiateViewController(
    withIdentifier: "summaryVC") as? SummaryViewController
    else {
      fatalError("Unable to instantiate a summary view controller")
    }

  controller.game = game
  return controller
}
```

This function creates and configures a new instance of a `SummaryViewController` from the Storyboard.

The decision for which of the three game view controllers you will show at any point is based on a combination of the current conversation and the current presentation style. The following function, which you will flesh out further as the project progresses, makes that decision. For now, you'll just show the `SummaryViewController`.

Add the following code to the extension:

```swift
private func presentViewController(
  forConversation conversation: MSConversation,
  withPresentationStyle style: MSMessagesAppPresentationStyle) {

  let controller: UIViewController

  // TODO: Create the right view controller here
  controller = instantiateSummaryViewController(game: nil)
  switchTo(viewController: controller)
}
```

The final piece is to call this function at just the right time. Add the following code to `willBecomeActive(with:)`:

```swift
presentViewController(forConversation: conversation, 
  withPresentationStyle: presentationStyle)
```

Build and run, and attach to the Messages app as you did in the previous chapter. You should see the summary view controller like so:

![iphone bordered](images/SummaryShown.png)

Tapping the "New Game" button does nothing yet. You'll fix this next.

Switch back to Xcode and open **MessagesViewController.swift**. The summary view controller has a delegate, which you need to set. Make `MessagesViewController` conform to `SummaryViewControllerDelegate` by adding the following extension:

```swift
extension MessagesViewController: SummaryViewControllerDelegate {
  func handleSummaryTap(forGame game: WenderPicGame?) {
    requestPresentationStyle(.expanded)
  }
}
```

You want the app to change to the expanded presentation style when you tap the button on the summary view controller so that you can do full-screen drawing.

Set the summary view controller's delegate by adding the following line to `instantiateSummaryViewController(game:)`, above the `return` statement:

```swift
controller.delegate = self
```

Build and run again, and tap the button; the app transitions to the expanded size!

![iphone bordered](images/SummaryShown2.png)

Nice, but that's only half of what you want. In the next part you'll switch to the drawing view controller as well.

## Switching view controllers

When the user taps to start a new game, the app transitions to the expanded presentation style. You want to create a new `WenderPicGame` and show the drawing view controller.

To do this, you need to call the utility function which chooses and presents the view controller whenever a change in the presentation style occurs.

To do this, open **MessagesViewController.swift** and add the following code to `willTransition(to:)`:

```swift
if let conversation = activeConversation {
  presentViewController(
    forConversation: conversation,
    withPresentationStyle: presentationStyle)
}
```

`activeConversation` is an optional property of `MSMessagesAppViewController`.

Inside your extension where you work with the child view controllers, add a utility function to the to make a new `DrawingViewController`:

```swift
private func instantiateDrawingViewController(game: WenderPicGame?) ->
  UIViewController {
  guard let controller = storyboard?.instantiateViewController(
    withIdentifier: "drawingVC") as? DrawingViewController
    else {
      fatalError("Unable to instantiate a drawing view controller")
    }

  controller.game = game
  return controller
}
```

This is almost identical to the function that creates the `SummaryViewController`, and only differs in the type of controller it returns.

Move to `presentViewController(forConversation: withPresentationStyle:)`. Find the `TODO:` comment you added earlier, and replace it, along with the line where you create the `SummaryViewController`, with the following:

```swift
switch style {
case .compact:
  controller = instantiateSummaryViewController(game: nil)
case .expanded:
  let newGame = WenderPicGame.newGame(drawerId: 
    conversation.localParticipantIdentifier)
  controller = instantiateDrawingViewController(game: newGame)
}
```

Instead of always creating the `SummaryViewController`, you are now switching on the presentation style. When the app is compact, the summary controller will be shown; when expanded, you'll see the drawing controller instead.

You create a new `WenderPicGame` using a UUID which represents the person doing the drawing. This UUID is available as a property on `MSConversation` and is consistent as long as the user keeps your app installed and enabled. This will let the app track the progress of a game between two participants.

Build and run, and tap the new game button, then let your artistic side go wild!

> **Note:** If you are using the Simulator to run the app and don't have a Force Touch trackpad, _do not_ run it on a 6S or higher, but instead on a 6 or lower. If you do run it on a 6S or higher, you won't be able to see what you're drawing. :]

![iphone bordered](images/Drawing1.png)

When you've run out of ink, hit the **Done** button...and nothing happens. You need to pack up your image in a message and send it to your friend. You'll solve this in the next part.

## Creating a message

The Messages framework has these model classes: a **Conversation**, a **Message**, and a **Session**. Here's a brief overview of each one.

### Conversation

`MSConversation` represents the back-and-forth stream of messages visible in the Messages app. This is the view that has the speech bubbles when you are texting.

You don't have full access to the conversation, which is understandable given the privacy implications. However, you _can_ access the following properties:

- `localParticipantIdentifier`: A UUID representing the user of the device ‚Äî i.e. the person who is sending messages from your extension. You used this when creating a new game earlier.
- `remoteParticipantIdentifiers`: An array of UUIDs representing the recipient(s) of any sent messages.
- `selectedMessage`: An optional property representing the selected message, _if_ the selected message was generated by your extension.

A conversation also has functions to add attachments, messages, text or stickers to the input field. Sending is still at the discretion of the user. This is similar to the way `MFMessageComposeViewController` works ‚Äì your app can populate a message and have it all set up and ready to go, but the user still has control over the actual _sending_ of the message. This way, nothing will be sent without the user's content.

### Message

`MSMessage` represents an interactive message. These are unique to, and only accessible by, your Messages app. If someone receives a message created by your extension, and they don't have it installed, they'll be prompted to install it. The most important properties of a message, which must be set before the message is sent, are the `layout` and the `URL`.

The `layout` is a separate class which controls how the message appears in the conversation. You don't get to fully customize the layout, you simply set whichever of its properties (image, caption and so on) are appropriate for your message.

The `URL` is your opportunity to send any custom data along with the message. You can include key-value pairs using `NSURLQueryItem`. You'll see these in action later in this chapter.

### Session

`MSSession` is used when a message is intended to be updated as the conversation progresses, rather than creating new entries in the conversation each time. If you create a message and associate it with a session, it will be shown normally. If you send _another_ message with the same session, the previous message will be moved down to the bottom of the conversation and be updated with the new information.

Imagine playing a game of Tic-Tac-Toe over Messages. With no sessions, the transcript would be a series of board images as the game progressed. With sessions, however, you'd only have one board image, with the latest positions appearing as each player made their move.

You can decide for yourself if sessions make sense for your messaging app.

### Sending a message

With that bit of theory covered, it's time to apply what you've learned. To recap the current state of the app, you can draw a picture, but not send it to your friend.

In **MessagesViewController.swift**, add the following function in a new extension:

```swift
extension MessagesViewController {
  private func composeMessage(with game: WenderPicGame,
  caption: String, session: MSSession? = .none) -> MSMessage {
    //1
    let layout = MSMessageTemplateLayout()
    //2
    layout.image = game.currentDrawing
    //3
    layout.caption = caption
    //4
    let message = MSMessage(session: session ?? MSSession())
    message.layout = layout

    return message
  }
}
```

Here's the play-by-play:

1. `MSMessageTemplateLayout` is currently the only available message layout class, so you have to use it. This could very well change in future versions of the Messages framework.
2. The `DrawingViewController` updates the game with the current state of the image. You use this image for the layout, so it will be part of the message.
3. The caption is text that appears under the image.
4. You create a new message with either the existing session, or if one doesn't exist, a new session.

The `DrawingViewController`, like the `SummaryViewController`, has a delegate which is called when the user taps the done button. Add the following extension to **MessagesViewController.swift**:

```swift
extension MessagesViewController: DrawingViewControllerDelegate {
  func handleDrawingComplete(game: WenderPicGame?) {
    defer { dismiss() }
    guard let
      conversation = activeConversation,
      game = game
    else { return }

    let message = composeMessage(
      with: game,
      caption: "Guess my WenderPic!",
      session: conversation.selectedMessage?.session!)

    conversation.insert(message) { (error) in
      if let error = error {
        print(error)
      }
    }
  }
}
```

This function uses the theory covered earlier. You get the current conversation and insert a custom message into it. Finally, you dismiss the drawing view.

Next, update `instantiateDrawingViewController(game:)` so that the delegate is set:

```swift
controller.delegate = self
```

Build and run, create another artistic, ink-limited masterpiece and tap the done button ‚Äì your message is ready to send!

![iphone bordered](images/MessageReady.png)

The appearance of the message, with the image and caption, are defined by the layout object. You don't get any control over the appearance ‚Äì but you don't have to do any work either. We'll call it a draw. :]

Tap the send button and the message will go to the other fake contact in the simulator. Tap the back button and switch to the other side of the conversation, and you'll see what the recipient would see. Tap the message and you'll simply see another drawing controller for a new game.

What's going on here? When the user taps the message, the extension transitions to the expanded presentation style. At the moment, that action simply starts a new game. In the next section, you'll add some data to the message so you can pass the game state back and forth between participants. This will let the recipient of a WenderPic send their guess back to the artist.

## Custom message content

In the discussion of `MSMessage` earlier, you learned that the `URL` property was your opportunity to add custom data to a message. You're going to do that now so that there's enough data in the message to recreate the `WenderPicGame` at the receiving end.

> **Note:** Messages apps are not yet available on macOS. The `URL` property has a second job - if your message is opened on a Mac, it will open the URL. We're not covering that in this chapter as it would involve you setting up a server that could handle the games.

To include data in a URL you'll need to use `URLQueryItem`. This struct represents a single key-value pair in a URL's query section ‚Äì this is the part of the URL you'd see as `?key=value&otherKey=otherValue`.

Open **WenderPicGame.swift** and add the following extension:

```swift
// MARK: Encoding / Decoding
extension WenderPicGame {
  var queryItems: [URLQueryItem] {
    var items = [URLQueryItem]()

    items.append(URLQueryItem(name: "word", value: word))
    items.append(URLQueryItem(name: "guesses", value:
      guesses.joined(separator: "::-::")))
    items.append(URLQueryItem(name: "drawerId", value:
      drawerId.uuidString))

    return items
  }
}
```

This puts all the important bits from the game into an array of query items: the word that the drawing is supposed to be, the person who drew it, and any guesses that have been made. You haven't made any guesses yet, but you will shortly.

You don't need to worry about the image that's been drawn, since that is available via the layout object attached to the incoming message.

Switch to **MessagesViewController.swift** and find the `composeMessage(with: caption: session:)`. Add the following code before the `return` statement:

```swift
var components = URLComponents()
components.queryItems = game.queryItems
message.url = components.url
```

You might not think that you can create a valid URL just by using query components, but you can! The above code creates a URL that looks like this:

```bash
?word=dog&drawerId=D5E356A9-0B6A-4441-AB6C-08D24DB255B2
```

Now that you're sending some custom content with your message, it's time to receive it at the other end of the conversation. Remember that at the moment, when the user receives and taps a message, they simply see the drawing controller reappear. Instead, your app _should_ attempt to recreate the game from the selected message and decide what to do based on that attempt.

First, you need to create a custom initializer for `WenderPicGame` that accepts some query items and an image. Switch to **WenderPicGame.swift** and add the following inside the encoding / decoding extension:

```swift
init?(queryItems: [URLQueryItem], drawing: UIImage?) {
  var word: String?
  var guesses = [String]()
  var drawerId: UUID?

  for item in queryItems {
    guard let value = item.value else { continue }

    switch item.name {
    case "word":
      word = value
    case "guesses":
      guesses = value.components(separatedBy: "::-::")
    case "drawerId":
      drawerId = UUID(uuidString: value)
    default:
      continue
    }
  }

  guard let decodedWord = word, decodedDrawerId = drawerId else {
    return nil
  }

  self.word = decodedWord
  self.guesses = guesses
  self.currentDrawing = drawing
  self.drawerId = decodedDrawerId
}
```

This failable initializer will return a valid game if the two mandatory properties ‚Äì `word` and the `drawerId` ‚Äì can be extracted from the query items.

For convenience, add the below initializer that takes a `MSMessage`, extracts the query items and image from it, and passes it to the previously defined initializer:

```swift
init?(message: MSMessage?) {
  guard let
    layout = message?.layout as? MSMessageTemplateLayout,
    messageURL = message?.url,
    urlComponents = URLComponents(url: messageURL, resolvingAgainstBaseURL: false),
    queryItems = urlComponents.queryItems
  else {
    return nil
  }

  self.init(queryItems: queryItems, drawing: layout.image)
}
```

**//TODO: In beta 2, the layout is not present. If this is the way things are in the final version, we'll need to change the way the image is transmitted.**

Now you have the ability to reconstruct a game from a message. If the user receives a drawing from their friend, they would want to see the `GuessViewController` when they tap it.

Switch to **MessagesViewController.swift** and add the following function to create the `GuessViewController` in the extension where you define the functions for dealing with child view controllers:

```swift
private func instantiateGuessViewController(game: WenderPicGame?) ->
  UIViewController {
  guard let controller = storyboard?.instantiateViewController(
    withIdentifier: "guessVC") as? GuessViewController
    else {
      fatalError("Unable to instantiate a guess view controller")
    }

  controller.game = game
  return controller
}
```

Now find the `switch` statement inside `presentViewController(forConversation withPresentationStyle:)`. Replace the lines after `case .expanded:` with the following:

```swift
if let game = WenderPicGame(message: conversation.selectedMessage) {
  controller = instantiateGuessViewController(game: game)
} else {
  let newGame = WenderPicGame.newGame(
    drawerId: conversation.localParticipantIdentifier)
  controller = instantiateDrawingViewController(game: newGame)
}
```

Remember that the expanded style is requested when the user taps the new game button or taps a received message. If the user has tapped a message, then the conversation would have a selected message, so therefore you'll be able to create a game and show the `GuessViewController`.

Build and run your app; create a sketch, switch to the other conversation view and tap the message:

![iphone bordered](images/Guess1.png)

In what should be a familiar pattern by now, you can enter a guess, but nothing will happen. The `GuessViewController` has a delegate property, and you need to set it up in the `MessagesViewController`.

Add the following extension to **MessagesViewController.swift** to conform to the `GuessViewControllerDelegate`:

```swift
extension MessagesViewController: GuessViewControllerDelegate {
  func handleGuessSubmission(forGame game: WenderPicGame, guess: String) {
    defer { dismiss() }
    guard let conversation = activeConversation else { return }

    let message: MSMessage

    if game.check(guess: guess) {
      // Correct answer
      message = composeMessage(with: game, caption: "üëç \(guess)",
        session: conversation.selectedMessage?.session)
    } else {
      // incorrect answer
      message = composeMessage(with: game, caption: "üëé \(guess)",
        session: conversation.selectedMessage?.session)
    }

    conversation.insert(message) { (error) in
      if let error = error {
        print(error)
      }
    }
  }
}
```

This function handles guesses by checking whether the guess is correct, and creates a reply with an appropriate caption.

Change `instantiateGuessViewController(game:)` to set the delegate property:

```swift
controller.delegate = self
```

Build and run again, bang out a sketch, switch sides, make a guess, and you'll see your guess return to the artist:

![iphone bordered](images/Guessed.png)

## Getting a second chance

You'll have noticed that you get a very limited supply of ink in this game. This means it's unlikely your opponent would guess your first attempt ‚Äì unless you're Henri Matisse.

In the case of an incorrect guess, it would be a good idea to add some more ink to give your opponent another chance. This is where the `drawerId` of the game comes in. At present, if you can recreate a game from the message, you show the `GuessViewController`. You're going to change this so that an incorrect guess lets the artist draw more.

Open **MessagesViewController.swift** and find `presentViewController(forConversation withPresentationStyle:)`. Change the code where a game has been created from the message to match the following:

**// TODO: This bit also doesn't work in beta 2 - the local participant identifer is the same for both sides of the conversation in the simulator :[. You can work around it by using conversation.remoteParticipantIdentifiers.first! instead, but I didn't want to commit that to the repo.**

```swift
if let game = WenderPicGame(message: conversation.selectedMessage) {
  if game.drawerId == conversation.localParticipantIdentifier {
    controller = instantiateDrawingViewController(game: game)
  } else {
    controller = instantiateGuessViewController(gasme: game)
  }
} else {
```

This will show the `DrawingViewController` if the game was originally started by the current user.

Build and run, send a drawing, make a guess, switch back to the original conversation and tap on the guess ‚Äì and now you're able to further refine your pi√®ce de resistance:

**TODO: screenshot of more drawing... waiting for beta fixes?**

Congratulations! You've successfully built a collaborative messaging app, which lets you pass custom information back and forward between two participants.

## Where to go from here?

Messages apps are an exciting new area for iOS. This is your chance to get involved from day one!

To learn more about the Messages framework check out the full documentation at [https://developer.apple.com/reference/messages](https://developer.apple.com/reference/messages).
