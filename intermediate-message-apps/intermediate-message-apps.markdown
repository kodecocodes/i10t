```metadata
author: "By Rich Turton"
number: "6"
title: "Chapter 6: Intermediate Message Apps"
```
# Chapter 6: Intermediate Message Apps

## Introduction

Chapter 5 showed you how you can build apps containing custom stickers for use in Messages. In this chapter you'll learn about sending fully custom, updatable messages. You're going to build a drawing and guessing game called **WenderPic**, where one player tries to draw something with a limited supply of ink, and their opponent tries to guess what it is. Drawings and guesses all travel via iMessage.

Read on to find out about the power of the Messages framework!

## Getting Started

Open the **WenderPic** starter project that comes with the materials for this chapter. There's quite a lot already present in the project, but none of it is really to do with Messages. Here's a quick tour of the project:

- Just like in the previous chapter, what you're building is a **MessagesExtension**, and not a "full" app like you're used to. The code for the extension is inside the **MessagesExtension** group.
- The **Models** group contains the model object for the game, **WenderPicGame**.
- The **Controllers** group contains the three view controllers used to play the game; **SummaryViewController**, which shows the title of the game and a start button, **DrawingViewController**, which handles the drawing, and **GuessesViewController**, which allows you to enter a guess.
- **MainInterface.storyboard** shows the root messages view controller, and the UI for the three game controllers. You'll build code to add these as child view controllers.

In this chapter, the root messages view controller will do a lot more work than it did in the previous one, so let's start with an overview of that.

## The Messages App View Controller

You briefly encountered `MSMessagesAppViewController` in the previous chapter. As you know already, it's a `UIViewController` subclass, but it gets several interesting functions called on it by the Messages framework.

There are lifecycle functions, similar to `viewDidLoad(_:)`, `viewWillAppear(_:)`, and alike:

- `willBecomeActive(with:)`: called when your Messages app is activated. As you'll learn later, the current conversation is passed in here.
- `didResignActive(with:)`: called when the user is done with your app, either because they switched conversations, switched to another app, or left the Messages app.

There are functions relating to the current conversation:

- `didReceive(_: conversation:)`: called when a message _that was generated by your extension_ is received. It's important to note that your extension does _not_ get told about every message your user receives—only those relevant to the extension.
- `didStartSending(_: conversation:)` and `didCancelSending(_: conversation:)`: called when the user hits send for one of your messages, or cancels sending.

Finally, there are functions relating to presentation style transitions. Messages apps can have two presentation styles; **Compact**, where the app fills the space normally taken by the keyboard, or **Expanded**, where the app fills the entire screen. `willTransition(to:)` and `didTransition(to:)` are called when the presentation style changes.

The idea of the `MSMessagesAppViewController` is to act as the root of the rest of your Messages extension, so it can handle all the things above. Typically, the interface for your app is handled in separate view controllers which are added as children—this is what you'll be doing in the next part.

## Adding the first child view controller

All of the game view controllers previously outlined will be added as children of `MessagesViewController.swift`. Adding a child view controller involves quite a lot of boilerplate, so you'll add a utility function so you don't have to duplicate yourself thrice.

Open **MessagesViewController.swift** and add the following extension:

```swift
// MARK: Child View Controllers
extension MessagesViewController {
  private func switchTo(viewController controller: UIViewController) {
    // Remove any existing child view controller
    for child in childViewControllers {
      child.willMove(toParentViewController: .none)
      child.view.removeFromSuperview()
      child.removeFromParentViewController()
    }

    // Add the new child view controller
    addChildViewController(controller)

    controller.view.translatesAutoresizingMaskIntoConstraints = false
    view.addSubview(controller.view)

    NSLayoutConstraint.activate([
      controller.view.leftAnchor.constraint(equalTo: view.leftAnchor),
      controller.view.rightAnchor.constraint(equalTo: view.rightAnchor),
      controller.view.topAnchor.constraint(equalTo: view.topAnchor),
      controller.view.bottomAnchor.constraint(equalTo: view.bottomAnchor)
      ])

    controller.didMove(toParentViewController: self)
  }
}
```

First you remove any existing child view controllers, then you add the controller passed in by the function, and finally you pin its view to all edges of the messages view controller's view.

The first view controller the user will see is the `SummaryViewController` - a controller with the title of the game and a "new game" button.

Add a utility function to the extension to create a new `SummaryViewController`:

```swift
private func instantiateSummaryViewController(game: WenderPicGame?) ->
  UIViewController {
  guard let controller = storyboard?.instantiateViewController(
    withIdentifier: "summaryVC") as? SummaryViewController
    else {
      fatalError("Unable to instantiate a summary view controller")
    }

  controller.game = game
  controller.delegate = self
  return controller
}
```

This function creates and configures a new instance of a `SummaryViewController` from the Storyboard.

The decision for which of the three game view controllers you will show at any point is based on a combination of the current conversation and the current presentation style. The following function, which you will fill out further as the project progresses, makes that decision. For now, you'll just show the `SummaryViewController`. Add this to the extension:

```swift
private func presentViewController(
  forConversation conversation: MSConversation,
  withPresentationStyle style: MSMessagesAppPresentationStyle) {

  let controller: UIViewController

  // TODO: Create the right view controller here
  controller = instantiateSummaryViewController(game: nil)
  switchTo(viewController: controller)
}
```

The final piece is to call this function at the right time. Add the following code to `willBecomeActive(with:)`:

```swift
presentViewController(forConversation: conversation, withPresentationStyle: presentationStyle)
```

Build and run, attaching to the Messages app as you did in the previous chapter, and you should see the summary view controller:

![iphone](images/SummaryShown.png)

Tapping the "New Game" button does nothing yet. You'll fix this next.

Switch back to Xcode and open **MessagesViewController.swift**. The summary view controller has a delegate, which you need to set. Make `MessagesViewController` conform to `SummaryViewControllerDelegate` by adding the following extension:

```swift
extension MessagesViewController: SummaryViewControllerDelegate {
  func handleSummaryTap(forGame game: WenderPicGame?) {
    requestPresentationStyle(.expanded)
  }
}
```

When the button on the summary view controller is tapped, you want the app to change to the expanded presentation style, so you can do full screen drawing.

Set the summary view controller's delegate by adding this line to `instantiateSummaryViewController(game:)`, above the `return` statement:

```swift
controller.delegate = self
```

Build and run again, then tap the button — the app transitions to the expanded size!

![iphone](images/SummaryShown2.png)

That's only half of what you want. In the next part you'll switch to the drawing view controller as well.

## Switching view controllers

When the user taps to start a new game, the app transitions to the expanded presentation style. You want to create a new `WenderPicGame` and show the drawing view controller.

To do this, you need to call the utility function which chooses and presents the view controller whenever a change in the presentation style occurs. To do this, open **MessagesViewController.swift** and add the following code to `willTransition(to:)`:

```swift
if let conversation = activeConversation {
  presentViewController(
    forConversation: conversation,
    withPresentationStyle: presentationStyle)
}
```

`activeConversation` is an optional property of `MSMessagesAppViewController`.

Inside your extension where you work with the child view controllers, add a utility function to the to make a new `DrawingViewController`:

```swift
private func instantiateDrawingViewController(game: WenderPicGame?) ->
  UIViewController {
  guard let controller = storyboard?.instantiateViewController(
    withIdentifier: "drawingVC") as? DrawingViewController
    else {
      fatalError("Unable to instantiate a drawing view controller")
    }

  controller.game = game
  return controller
}
```

This is almost identical to the function that creates the `SummaryViewController`, and only differs in the type of controller it returns.

Move to `presentViewController(forConversation: withPresentationStyle:)`. Find the `TODO:` comment you added earlier, and replace it, along with the line where you create the `SummaryViewController`, with the following:

```swift
switch style {
case .compact:
  controller = instantiateSummaryViewController(game: nil)
case .expanded:
  let newGame = WenderPicGame.newGame(drawerId: conversation.localParticipantIdentifier)
  controller = instantiateDrawingViewController(game: newGame)
}
```

Instead of always creating the `SummaryViewController`, you are now switching on the presentation style. The summary controller will be shown when the app is compact, and the drawing controller when expanded.

You create a new `WenderPicGame` using a UUID which represents the person who is doing the drawing. This UUID is available as a property on `MSConversation` and is consistent as long as the user keeps your app installed and enabled. This is going to allow the app to track the progress of a game between two participants.

Build and run, and tap the new game button, then do some drawing!

> **Note:** If you are using the Simulator to run the app and don't have a Force Touch trackpad, _do not_ run it on a 6S or higher, but instead on a 6 or lower. If you don't, you will not be able to see what you're drawing :]

![iphone](images/Drawing1.png)

When you've run out of ink and hit the **Done** button... nothing happens. You want to pack up your image in a message and send it to your friend. This you'll work on in the next part.

## Creating a message

The Messages framework has these model classes: a Conversation, a Message, and a Session. Here's a brief overview of each one.

### Conversation

`MSConversation` represents the back-and-forth stream of messages currently visible in the Messages app. This is the view with the speech bubbles when you are texting.

You don't have full access to the conversation, which is understandable given the privacy implications that would have. You _can_ access the following properties:

- `localParticipantIdentifier`: a UUID representing the user of the device — i.e. the person who is sending messages from your extension. You used this when creating a new game earlier.
- `remoteParticipantIdentifiers`: an array of UUIDs representing the recipient(s) of any sent messages.
- `selectedMessage`: an optional property representing the selected message, _if_ the selected message was generated by your extension.

A conversation also has functions to add attachments, messages, text or stickers into the input field. Sending is still at the discretion of the user. This is similar to the way `MFMessageComposeViewController` works - your app can populate a message and set it all up ready to go, but the user still has control over the actual sending of the message. That way, nothing will be sent without their content.

### Message

`MSMessage` represents an interactive message. These are unique to, and only accessible by, your Messages app. If someone receives a message created by your extension, and they don't have it installed, they'll be prompted to install it. The most important properties of a message, which must be set before the message is sent, are the `layout` and the `URL`.

The `layout` is a separate class which controls how the message appears in the conversation. You don't get to fully customize the layout, you simply set whichever of its properties (image, caption and so on) are appropriate for your message.

The `URL` is your opportunity to send any custom data along with the message. You can include key-value pairs using `NSURLQueryItem`. You'll see these in action later in this chapter.

### Session

`MSSession` is used when a message is intended to be updated as the conversation progresses, rather than having new entries in the conversation each time. If you create a message and associate it with a session, it will be shown normally. If you send _another_ message with the same session, the previous message will be moved down to the bottom of the conversation and be updated with the new information.

Imagine playing a game of Tic-Tac-Toe over messages. With no sessions, the transcript would be a series of board images as more and more moves were played. With sessions, however, you'd only have one board image, with the latest positions on it. You can decide for yourself if sessions make sense for your messaging app.

### Back to work!

With that bit of theory covered, it's time to apply it. At the moment, you can draw a picture, but not send it to your friend.

In **MessagesViewController.swift**, add the following function in a new extension:

```swift
extension MessagesViewController {
  private func composeMessage(with game: WenderPicGame,
  caption: String, session: MSSession? = .none) -> MSMessage {
    //1
    let layout = MSMessageTemplateLayout()
    //2
    layout.image = game.currentDrawing
    //3
    layout.caption = caption
    //4
    let message = MSMessage(session: session ?? MSSession())
    message.layout = layout

    return message
  }
}
```

Here's the step-by-step:

1. `MSMessageTemplateLayout` is currently the only available message layout class, so you have to use it. This could very well change further down the line as the Messages framework grows, though.
2. The `DrawingViewController` will update the game with the current state of the image. You use this image for the layout, so it will be part of the message.
3. The caption is text that will appear under the image.
4. You create a new message, either with the existing session, or with a new session if one does not exist.

The `DrawingViewController`, like the `SummaryViewController`, has a delegate which is called when the done button is tapped. Add the following extension to **MessagesViewController.swift**:

```swift
extension MessagesViewController: DrawingViewControllerDelegate {
  func handleDrawingComplete(game: WenderPicGame?) {
    defer { dismiss() }
    guard let
      conversation = activeConversation,
      game = game
    else { return }

    let message = composeMessage(
      with: game,
      caption: "Guess my WenderPic!",
      session: conversation.selectedMessage?.session!)

    conversation.insert(message) { (error) in
      if let error = error {
        print(error)
      }
    }
  }
}
```

This function uses the theory just covered. You get the current conversation and insert a custom message into it. Finally, you dismiss the drawing view.

Next, update `instantiateDrawingViewController(game:)` so that the delegate is set:

```swift
controller.delegate = self
```

Build and run, do a drawing and tap the done button - your message is ready to send!

![iphone](images/MessageReady.png)

The appearance of the message, with the image and caption, are defined by the layout object. You don't get any control over the appearance, but you don't have to do any work either :]

Tap the send button and the message will go to the other pretend contact in the Simulator. Tap the back button and switch to the other side of the conversation, and you'll see what the message looks like to the recipient. If you tap the message, you just get shown another drawing controller for a new game.

What's happening here is that when the user taps the message, the extension transitions to the expanded presentation style, and at the moment that just starts a new game. In the next part you're going to add some data to the message so that the game state can be passed back and forth between participants. This will allow the recipient of a WenderPic to make and send a guess.

## Custom message content

In the discussion of `MSMessage` earlier you learned that the `URL` property was your opportunity to add custom data to a message. You're going to do that now to include enough data in the message for the recipient to be able to recreate the `WenderPicGame` from the sender's device.

> **Note:** Messages apps are not yet available on macOS. The `URL` property has a second job - if your message is opened on a Mac, it will open the URL. We're not covering that in this chapter as it would involve you setting up a server that could handle the games.

The way to include data in a URL is to use `URLQueryItem`. This struct represents a single key-value pair in a URL's query section - this is the part of the URL you'd see as `?key=value&otherKey=otherValue`.

Open **WenderPicGame.swift** and add the following extension:

```swift
// MARK: Encoding / Decoding
extension WenderPicGame {
  var queryItems: [URLQueryItem] {
    var items = [URLQueryItem]()

    items.append(URLQueryItem(name: "word", value: word))
    items.append(URLQueryItem(name: "guesses", value:
      guesses.joined(separator: "::-::")))
    items.append(URLQueryItem(name: "drawerId", value:
      drawerId.uuidString))

    return items
  }
}
```

This puts everything important from the game into an array of query items. So far, that's the word that the drawing is supposed to be, the person who drew it, and any guesses that have been made. You haven't done any guesses yet, but you will shortly.

You don't need to worry about the image that's been drawn, since that is available via the layout object attached to the incoming message.

Switch to **MessagesViewController.swift** and find the `composeMessage(with: caption: session:)`. Add the following code before the `return` statement:

```swift
var components = URLComponents()
components.queryItems = game.queryItems
message.url = components.url
```

You might not think that you can create a valid URL just by using query components, but you actually can. The above code makes a URL that looks like this:

```bash
?word=dog&drawerId=D5E356A9-0B6A-4441-AB6C-08D24DB255B2
```

Now that you're sending some custom content with your message, it's time to receive it at the other end of the conversation. Remember that currently, when the user receives and taps a message, they just see the drawing controller again. What should happen is that you should try to recreate the game from the selected message, and decide what to do based on that.

First of all you need to create a custom initializer for `WenderPicGame` that can take some query items and an image. Switch to **WenderPicGame.swift** and add the following inside the encoding / decoding extension:

```swift
init?(queryItems: [URLQueryItem], drawing: UIImage?) {
  var word: String?
  var guesses = [String]()
  var drawerId: UUID?

  for item in queryItems {
    guard let value = item.value else { continue }

    switch item.name {
    case "word":
      word = value
    case "guesses":
      guesses = value.components(separatedBy: "::-::")
    case "drawerId":
      drawerId = UUID(uuidString: value)
    default:
      continue
    }
  }

  guard let decodedWord = word, decodedDrawerId = drawerId else {
    return nil
  }

  self.word = decodedWord
  self.guesses = guesses
  self.currentDrawing = drawing
  self.drawerId = decodedDrawerId
}
```

This_failable initializer will return a valid game if the two mandatory properties, the `word` and the `drawerId`, can be extracted from the query items. For convenience, add another initializer that takes a `MSMessage`, extracts the query items and image from it, and parses it to the previously defined initializer:

```swift
init?(message: MSMessage?) {
  guard let
    layout = message?.layout as? MSMessageTemplateLayout,
    messageURL = message?.url,
    urlComponents = URLComponents(url: messageURL, resolvingAgainstBaseURL: false),
    queryItems = urlComponents.queryItems
  else {
    return nil
  }

  self.init(queryItems: queryItems, drawing: layout.image)
}
```

**//TODO: In beta 2, the layout is not present. If this is the way things are in the final version, we'll need to change the way the image is transmitted.**

Now you have the capability to create a game from a message. If the user receives a drawing from their friend, they want to see the `GuessViewController` when they tap it.

Switch to **MessagesViewController.swift** and add a function to create the `GuessViewController` in the extension where you define the functions for dealing with child view controllers.

```swift
private func instantiateGuessViewController(game: WenderPicGame?) ->
  UIViewController {
  guard let controller = storyboard?.instantiateViewController(
    withIdentifier: "guessVC") as? GuessViewController
    else {
      fatalError("Unable to instantiate a guess view controller")
    }

  controller.game = game
  return controller
}
```

Now find the switch statement inside `presentViewController(forConversation withPresentationStyle:)`. Replace the lines after `case .expanded:` with the following:

```swift
if let game = WenderPicGame(message: conversation.selectedMessage) {
  controller = instantiateGuessViewController(game: game)
} else {
  let newGame = WenderPicGame.newGame(
    drawerId: conversation.localParticipantIdentifier)
  controller = instantiateDrawingViewController(game: newGame)
}
```

Remember that the expanded style is requested when the user taps the new game button or taps a received message. If the user has tapped a message, then the conversation will have a selected message, so you will be able to create a game and show the `GuessViewController`.

Build and run, send a drawing, switch to the other conversation view and tap the message:

![iphone](images/Guess1.png)

In what should be a familiar pattern by now, you can enter a guess, but nothing will happen. The `GuessViewController` has a delegate property, and you need to set it up in the `MessagesViewController`.

Add the following extension to **MessagesViewController.swift** to conform to the `GuessViewControllerDelegate`:

```swift
extension MessagesViewController: GuessViewControllerDelegate {
  func handleGuessSubmission(forGame game: WenderPicGame, guess: String) {
    defer { dismiss() }
    guard let conversation = activeConversation else { return }

    let message: MSMessage

    if game.check(guess: guess) {
      // Correct answer
      message = composeMessage(with: game, caption: "👍 \(guess)",
        session: conversation.selectedMessage?.session)
    } else {
      // incorrect answer
      message = composeMessage(with: game, caption: "👎 \(guess)",
        session: conversation.selectedMessage?.session)
    }

    conversation.insert(message) { (error) in
      if let error = error {
        print(error)
      }
    }
  }
}
```

This function handles guesses by checking if the guess is correct or not, and creating and preparing a reply to send with an appropriate caption.

Change `instantiateGuessViewController(game:)` to set the delegate property:

```swift
controller.delegate = self
```

Build and run again, send a drawing, make a guess, and you'll see your guess go back:

![iphone](images/Guessed.png)

## Whose guess is it anyway?

You'll have noticed that you get a very limited supply of ink in this game. This means your first drawing is highly unlikely to be guessed correctly, unless you're Henri Matisse.

When you get an incorrect guess back, it would be good to be able to add some more drawing to give your opponent another chance. This is where the `drawerId` of the game comes in. At the moment, if you can recreate a game from the message, you show the `GuessViewController`. You're going to change this so that if the game is one where the current user did the drawing, they get to do more drawing.

Open **MessagesViewController.swift** and find `presentViewController(forConversation withPresentationStyle:)`. Change the code where a game has been created from the message to match the following:

**// TODO: This bit also doesn't work in beta 2 - the local participant identifer is the same for both sides of the conversation in the simulator :[. You can work around it by using conversation.remoteParticipantIdentifiers.first! instead, but I didn't want to commit that to the repo.**

```swift
if let game = WenderPicGame(message: conversation.selectedMessage) {
  if game.drawerId == conversation.localParticipantIdentifier {
    controller = instantiateDrawingViewController(game: game)
  } else {
    controller = instantiateGuessViewController(game: game)
  }
} else {
```

This will show the `DrawingViewController` if the game was originally started by the current user.

Build and run, send a drawing, make a guess, switch back to the original conversation and tap on the guess - you get to add more ink:

**TODO: screenshot of more drawing... waiting for beta fixes?**

Congratulations! You've successfully built a collaborative messaging app, which allows you to pass custom information back and forward between two participants.

## Where to go from here?

Messages apps are an exciting new area for iOS - this is your chance to get involved on day one!

To learn more about the Messages framework you can find the full documentation at [https://developer.apple.com/reference/messages](https://developer.apple.com/reference/messages).
